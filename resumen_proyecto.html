Proyecto: Motor de Juegos de Ladrillos
Este proyecto pr√°ctico consiste en la construcci√≥n de un motor de juegos que interpreta y ejecuta juegos definidos por un lenguaje de programaci√≥n dise√±ado por ustedes. El proyecto se realizar√° en equipos de hasta 3 personas y debe cumplir con las siguientes restricciones de hardware:

Compacto: El ejecutable y los archivos del juego deben caber en un disquete de 1.44 MB.
Hardware antiguo: El motor debe ser compatible con un sistema operativo Windows XP y un procesador AMD Athlon XP.

Entrega 1: El Analizador de Lenguaje y la Tabla de S√≠mbolos
Esta primera fase se centra en el an√°lisis del lenguaje y la abstracci√≥n. El objetivo es que los equipos definan un lenguaje de programaci√≥n para describir las reglas de un juego de ladrillos y construyan un programa que pueda leer, entender y almacenar esa informaci√≥n.

1.1. Tareas Clave
Definici√≥n del Lenguaje:Dise√±en la sintaxis de su lenguaje. Piensen en qu√© elementos necesitan para describir un juego: colores de los ladrillos, velocidad de ca√≠da, puntuaci√≥n por l√≠nea, etc.
Definan la gram√°tica de su lenguaje de forma clara. Por ejemplo, color_ladrillo = "rojo", velocidad = 100, etc.

1.2. An√°lisis L√©xico (Lexer Version 1):
Escriban un programa que lea el archivo de texto que contiene las reglas del juego.
Este programa debe identificar y clasificar las "palabras" o tokens del lenguaje, como palabras clave (color, velocidad), identificadores (ladrillo_rojo), n√∫meros (100), y operadores (=). Un token es la unidad m√°s peque√±a con significado en un programa.

1.3. An√°lisis Sint√°ctico (Parser Version 1):
El parser recibir√° los tokens del lexer. Su trabajo es verificar que la secuencia de tokens cumpla con la gram√°tica que definieron.
Si la sintaxis es correcta, el parser construir√° una estructura de datos para representar el juego. Pueden usar un √Årbol de Sintaxis Abstracta (AST) para una representaci√≥n m√°s formal, o simplemente un diccionario anidado en Python para una implementaci√≥n m√°s sencilla. Esta estructura de datos ser√° la "receta" del juego.
Si la sintaxis es incorrecta, el programa debe mostrar un mensaje de error claro y √∫til indicando d√≥nde se encuentra el problema.

1.4. Tabla de S√≠mbolos:
Durante el an√°lisis, el programa debe construir una tabla de s√≠mbolos. Esta es una estructura de datos que almacena informaci√≥n sobre los elementos del juego.
Por ejemplo, si el archivo de juego tiene la l√≠nea velocidad = 100, la tabla de s√≠mbolos podr√≠a guardar una entrada que asocie el identificador velocidad con el valor 100. Esta tabla es crucial porque ser√° la fuente de informaci√≥n para el motor de juego en la siguiente entrega.

1.5. Entregable
* Documentaci√≥n T√©cnica: Un documento que defina su lenguaje de programaci√≥n, incluyendo la sintaxis y una explicaci√≥n de cada comando.
* C√≥digo Fuente y Programa Ejecutable: El programa que realiza el an√°lisis l√©xico y sint√°ctico. Debe poder ejecutarse en la m√°quina con las restricciones, procesar al menos dos archivos de juego de ejemplo (tetris.brik y snake.brik) y, si hay errores de sintaxis, reportarlos correctamente.

Entrega 2: El Motor Gr√°fico y de Juego üñ•Ô∏è
Esta fase se enfoca en el hardware y la implementaci√≥n a bajo nivel. El objetivo es crear un motor de juego que pueda renderizar gr√°ficos y manejar la l√≥gica b√°sica, sin saber nada espec√≠fico sobre los juegos que ejecutar√°.

2.1. Tareas Clave
Configuraci√≥n del Motor:
Inicialicen un entorno gr√°fico. El motor debe crear una ventana con una resoluci√≥n de 640x480 p√≠xeles.
Bucle Principal (Game Loop):
Implementen el bucle de juego principal. Este es el coraz√≥n del motor, un ciclo infinito que realiza tres tareas principales en cada "frame":
Gesti√≥n de eventos: Leer las entradas del usuario (ej., teclado).
Actualizaciones l√≥gicas: Mover objetos, verificar colisiones, etc.
Renderizado: Dibujar los gr√°ficos en la pantalla.
Funciones Gr√°ficas B√°sicas:
Desarrollen funciones para dibujar los elementos del juego. Por ejemplo:
dibujar_ladrillo(x, y, color): Una funci√≥n que dibuja un bloque en las coordenadas (x, y) con el color especificado.
dibujar_texto(x, y, texto): Para mostrar la puntuaci√≥n, mensajes de juego, etc.
Control de Entradas:
Creen un m√≥dulo para gestionar las pulsaciones de teclas. El motor debe ser capaz de detectar si el usuario presiona una tecla (por ejemplo, arriba, abajo, izquierda, derecha) para mover los ladrillos.

2.2. Entregable
Documentaci√≥n T√©cnica: Descripci√≥n del dise√±o del motor de juego y sus funciones.
C√≥digo Fuente y Programa Ejecutable: El motor de juego que se ejecute en la m√°quina con las restricciones. Para la demostraci√≥n, el motor debe ser capaz de mostrar un ladrillo en la pantalla y permitir al usuario moverlo con las teclas, confirmando que el control de entrada funciona.

Entrega 3: Integraci√≥n y L√≥gica del Juego
Esta es la fase de abstracci√≥n metaling√º√≠stica, donde las dos entregas anteriores se unen. El objetivo es que el motor de la Entrega 2 utilice la informaci√≥n del analizador de la Entrega 1 para ejecutar la l√≥gica de los juegos, sin que esta l√≥gica est√© codificada directamente en el motor.

3.1. Tareas Clave
Integraci√≥n: Modifiquen el motor de la Entrega 2 para que, en lugar de usar valores codificados (como la velocidad o el color), lea el archivo de juego y utilice la tabla de s√≠mbolos generada por el analizador de la Entrega 1.
Motor de Reglas: Implementen la l√≥gica del juego. El bucle principal del motor debe leer los valores de la tabla de s√≠mbolos y aplicarlos. Por ejemplo, si la tabla de s√≠mbolos indica que la gravedad es 1, el motor debe actualizar la posici√≥n de la pieza para que caiga un bloque por segundo. La clave es que el motor interprete las reglas del juego, no que las tenga "cableadas" en el c√≥digo.
Creaci√≥n de Contenido: Cada equipo debe crear al menos dos juegos completos (tetris.brik y snake.brik) utilizando su lenguaje. Estos archivos de texto son la "prueba de fuego" de que su lenguaje es lo suficientemente expresivo y que su motor puede interpretarlo correctamente.

3.2. Entregable
Documentaci√≥n T√©cnica: Actualizaci√≥n de la documentaci√≥n para reflejar la integraci√≥n.
C√≥digo Fuente y Programa Ejecutable: El programa final, el motor de juegos, que al ser ejecutado permita seleccionar y jugar los dos juegos de ejemplo. El √©xito de la prueba es que ambos juegos se ejecuten correctamente sin necesidad de cambiar el c√≥digo del motor, demostrando que la l√≥gica est√° en el archivo de texto.

Este proyecto no solo pondr√° a prueba su conocimiento sobre la teor√≠a de lenguajes, sino que tambi√©n los desafiar√° en el desarrollo de software bajo restricciones reales de hardware. Es una excelente oportunidad para aplicar conceptos como el dise√±o de lenguajes, el an√°lisis sint√°ctico y la abstracci√≥n.
